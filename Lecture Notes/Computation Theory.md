-  _**Lecture 1**_ 
    - **Hilbert's Entscheidungsproblem**
        - Is there an **algorithm** which when fed **any statement** in the formal language of first-order arithmetic, determines **in a finite number of steps**  _**whether the statement is provable**_  from Peano’s axioms for arithmetic, using the usual rules of first-order logic?  
        - Describe the problem, and is it provable?→can we use an algorithm to **decide whether a statement** (written in formal language) is **provable ** _**in a finite number of steps**_ . It is **not **solvable. 
        - A **decision problem** is→Given a **set S **whose **elements are finite data structures **(simply means some data to read, could be formulas of 1st order arithmetic), and **a property P of S**. The decision problem is **find an algorithm that terminates with 0 or 1 **-  _**only yields 1 when fed s with property p**_ **.** 
    - **What is an algorithm**
        - Common features  ↓ 
            - **Finite **description of the procedure, in terms of elementary operations
            - **Deterministic** 
            - We can recognize when it **does terminate** 
        - Turing ⇒ Turing Machines. Church ⇒ Lambda calc. Allows for regarding algorithms as data, on which algos can act
    - **The Halting Problem**
        - Is the **decision problem **with→Set S of **all pairs (A,D) **- **A **is an **algorithm **and** D **is a **datapoint **that A works on. **Property P holds if A eventually halts**. $A(D)\downarrow$  - means A halts on D.
        - Church and Turing found, no algorithm H such that H(A,D) solves the problem. 
        - Describe the **Informal proof, **by contra ↓ 
            - If there were an algorithm H(A,D) that solved the halting problem.
            - let C be: "input A; compute H(A,A); if H(A,A)=0 then return 1, else loop forever."
            - So we know **within C **- if A(A) runs forever C halts, and A(A) halts C runs forever. But what if we apply C to itself? ⇒ If C(C) runs forever C(C) halts, and C(C) halts C(C) run forever
            - This is a contradiction.
            - ![](local://C:/Users/malac/remnote/Malachy_O'Connor/files/siFmc-hoYXZI03PTHj1UFNUEdQ78lNvCIy_Lq-2rLG89Dm5egQBa19h0-bBEX6537hlsOchorTSYTvpREK_mMfO9G7wYXdk5et3HPJbSB58zkSZEIXsHM7pK8GpCq6ns.png) 
            - ![](local://C:/Users/malac/remnote/Malachy_O'Connor/files/run013sEKw6k5TVw9nteiquELNVaqM5bDeYaVbYE1_S7taZeJaLzd4NxVPaGJmBn_fjjJdso-ORkObK8Pm4ChpUFNbzwwjGY0_OkTQhLmcSlTCcc0QHNJd-u2vnMZzDE.png) 
        - The dubious sections of this argument are ↓ 
            - Can we make C out of H?  
            - Is H(A,A) allowed? 
    - **From HP to that German one**
        - Rephrased the question to - If a statement in arithmetic is **provable **then A(D) halts. 
        - They encoded an instance of the halting problem as arithmetic statements $\Phi$, such that if you could decide if $\Phi$ was provable, it decides if the program halts. But as solving the halting problem is impossible, so too is the **Entscheidungsproblem.** 
    - **Hilbert's 10th Problem**
        - A **Diophantine equation** is→an **equation with polynomials** with a **fixed number of unknowns**, with a fixed number of **natural number** coefficients ( __implies whole number coefficients)__ . Where the **only solutions of interest are the integer values**. ![](local://C:/Users/malac/remnote/Malachy_O'Connor/files/qxLC7QDSPKmIEmN0o7zNfIiL7OfeoGT_jHowoaRR1nzL5UOXpWThiBK9ZPofEn-nENcVeaaDMfGMlnCnn1DtFl2nkWVM1rw24jTsI5tOrgNSIiPKJfia7ZfO9s2IojQy.png) 
        - Give an algorithm which, when started with any **Diophantine** equation, determines in a finite number of operations **whether or not there are natural numbers satisfying the equation**.   
        - It is **undecidable - **found by **reduction from the halting problem.** 
    - 
