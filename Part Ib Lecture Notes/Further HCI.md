-  _**Lecture 1**_   Theory Driven approaches to HCI
    - **UI Design** 
        - How would you go about designing UIs
        - How do we know what a good UI is?
        - Could our UI be improved?
        - How do the answers to these questions differ between a **Family home printer,** **Facebook privacy** settings and a **visual programming UI**.
    - HCI Theories
        - **Theories give a ** __**critical perspective. **__  
        - What is the Gestalt theory ↓ 
            - The Gestalt theory of perceptual organisation, is a **theory on how people enjoy and perceive** **marks on a screen**. 
            - **Continuity **-  Continuity is that our brains tend to see objects as continuous or smooth rather than disjointed or discontinuous  
![](local:///home/mali/remnote/remnote-614c8a3b6997e6001643dfce/files/S9nuVLYthKXuGuFdgE0vUibDhynR1XvRBkxj7A49bUFCDbklzBEEYrBfGvydkIWsIyHIMaS-PA83-IOGmAcF8p1gxDgRaoMxYj1dWxV41qa34GaHdv9GBZPGHPAR_SWO.png) 
            - **Similarity **- how we piece information together by how similar objects are  ![](local:///home/mali/remnote/remnote-614c8a3b6997e6001643dfce/files/eUxUjVwn49Oo06KksV7SpLxLR8BMg9p8X2E0cxeCb1bRrPDOn6RYPGsj4EAS7gDVUAiqf9cKiFeJIx70EqqrqdJSfF3NyNcwFotE37YD1Tv0dpr6RNgRp9bceYXyEQ2H.png) 
            - **Closure** - when individuals fill in the blanks
  ![](local:///home/mali/remnote/remnote-614c8a3b6997e6001643dfce/files/YZvz-laQSfMkMiW4HmZ0iqXrK6S0VistpU_v_KyJ73PnM1Yk1MJeF7-yj6Wnuuc6k9wtYW6bbQ0jXMQzsQ219QwhXqe2GlXJbvVMcpbHZ4dk7a2eKnuXgTuD-EezuoG5.png)** ** 
        - Using Closures for visual programming design of lines: Lines between blocks could be blocked.
        - Problematic Similarity in Visual programming - Given that objects look the same, code block and a number, is that a problem? Non-programmers think a number & a computation resulting in a numbers are not the same. 
        - **Summary of Gestalt theory application** 
            - How can we use Gestalt theory to **evaluate a design**?―Take a candidate design - predict some properties that **will work well** and some that **will cause problems**. E.g. in visual programming using blocks, the blocks might look too similar - **so wont work**. Lines between blocks that are hidden use closure - **so will work.**![](local:///home/mali/remnote/remnote-614c8a3b6997e6001643dfce/files/2MczzW4gbyTgZC1oV9UKKiGWX9i7WXxqj_Eaftmw8XBuh6bQ8y01DEq4ScxqDXxBxlHrD-qgwmlA4kPUDG5LprvCw0768Bf81HwlGIzm-C1uHJxStbrBq7LPvAyXzNym.png) 
    - **Iterative Design**
        - Describe **iterative design**―Iterative design is the **process of expanding and contracting your designs over time**. At first you **generate a batch of designs**, then **distil the good parts** and **combine them** - discarding some ideas. **Then you generate more ideas** this is called 'creative disruption' (make sure you've explored the problem space and have not hit a local maxima) and** repeat this process. **![](local:///home/mali/remnote/remnote-614c8a3b6997e6001643dfce/files/ubld7KHOuUQKWOjU9NtbzKy3_pwVT6Ywop-fIqjwxA0Dcm7ATSKnN8uZSBPjAP7jcZZgEn_po9dBjrIQZVyVvgmS9F3GTQXEIkPfSrj30judQBs86_ndNfgwMVGwmVpY.png) 
        - **Gestalt swapping** is―If a **design depends upon a certain Gestalt property** - force yourself to **use a different Gestalt property**. It's not intended to be an end answer, rather to g**ive new ideas** from which the good parts can be pulled.
For example, instead of emojis as variable names for similarity - perhaps we can colour variables instead.
    - **Why theory in HCI?**
        - Interested in making interaction 'better' - theories s us ways of criticising proposed designs and ...
    - **Three waves of HCI**
        - First Wave - Theory from Human factors, Ergonomics and Cognitive Science
        - Second Wave - Theory from Anthropology, Sociology and Work Psychology
        - Third Wave - Theory from Art, Philosophy and Design
        - **First Wave**
            - HCI as a engineering discipline, analyse the person as a part of a system. E.g. the Apollo-Soyuz controls. Additionally, ergonomic factors - can they reach that etc.
            - The "user interface" is a separate module, designed independently of the main system
            - Design goal is efficiency (speed and accuracy) for a human operator to achieve well-defined functions.
            - Use methods from cognitive science to model users' perception, decision and action processes and predict usability.
        - **Second Wave**
            - HCI as a social system - take account of information systems outside the computer, including conversations, paper and physical settings.
            - More and more people using computers - the system becomes a whole organisation with many computers
            - Study the context where people work, understand different ways of seeing the world around the world.
            - Integrate stakeholders into the design process.
        - **Third Wave**
            - HCI as culture and experience. Computers everywhere mixes public (office) and private (bedroom).
            - Outside the workplace, efficiency not necessarily a priority - Usage discretionary (no choice of software in the workplace, but can decide at home) and UX includes aesthetics, affect.
            - Design experiments are speculative and interpretive (Not as concrete as ergonomics) - need a Critical assessment of how this is meaningful. 
        - **Alternative Perspectives** 
            - Positive computing that focuses on wellbeing, flow, empathy, mindfulness, altruism (Calvo and Peters), work  on inclusion and accessibility that addresses physical and sensory capabilities, ageing, low income  and human rights, or explicitly critical points of view such as Bardzell’s feminist utopianism, where  design critique directly attacks the mechanisms of institutional privilege, using practices that are  designed to amplify marginalized voices when thinking about the future.
    - 
-  _**Lecture 2**_   Visual Representation
    - **The range of visual representations** 
        - **Typography and text** can communicate lots of information, additionally how you arrange text on a screen. Also colour, bold, italic font .etc.
        - ![](https://lh4.googleusercontent.com/RI6Oav-jMszLJZPiJsmQgduSUno7oBocjOxb8m2DssH7vzGRCQa3mpLhmkHDNz-skqnjYBfo5CHhP1SqOQpoXXdnjTyQIs2PveLiiUdBvwHPCZsBYozGnKFa05r2LX0wZcl_4Vgi0P9y)   
        - **Maps and Graphs**
            - **Graphs **used to show trends, time along x. 
            - ![](https://lh4.googleusercontent.com/ZRQ-igOVW5q4KUxC0TF0I4SW1a0_rX1Tl0kxGGL8jSLQC_p5hPgzk9wdxwXeRHb6Lxo0OWfSWOGVwTaoZ72_hS1VqdzWO-0sjaYVaJGwDCDvmZIQvqZ0e2-ub8p3ajzgxUCuDjvghGwL)   
            - **Maps**
            - ![](https://lh4.googleusercontent.com/H4cahK72-SP_vZB20EHTUsVnwqJ50TaJ8pRwp6tdvAJjr9H29yKrSNpg05E7s6Lh7wAVXaqTN297mcdEiE58QGZ8pIPXtklF_JjqcHsGGFY2xkPTWkXe9hjZZHzSF0vETNUYblzKgh9W)   
        - **Schematic Drawings**
            - Making pictures of things more useful, by making more abstract/computational. 
            - Lines carrying force, an example of an image that calculated itself - Bridge: 
            - ![](local:///home/mali/remnote/remnote-614c8a3b6997e6001643dfce/files/pkGAfJCu1IiSaVYkAptCxfoyio1KNU-9RakGH3hGrfL8pU8uCCZgjRTX8zKHYXioXkXSYVU4D6tPCqwjS4BeGKJeLo9pIzFenfqFYNyOpBno2V-uUnhbb9Quqarppb-w.png) 
            - ![](https://lh4.googleusercontent.com/HAjJ8k6s9k5M5g54pTN0GdmOJD3AarSfUvbSnK0ze_m0MbgZ2AvpcbicNQ9G6Gt0WkGyIPwgMDgzYVH-8mqe8E15t7WEOK9W9aKXpkXeO7BK8FOjJFzkdz5_a1qY_P-x1_p9frEHfWa9)   **VS  **![](https://lh5.googleusercontent.com/MnhQ3OSR32DU7bX5WzX8JcAD4rsla0i7HlsRT1LllmwB9P2t-U-FxVoELS2UHtACsq0f4kLwYaa7H1_Yl4gpoU9sYfxtfQhnAwQMoZNK3U80hgmfw_s2NrOJMzu5fEMRh_44hhjTmus1)
            - London underground map designed by electrical engineer.
            - Direct mapping vs set of logical relations. Realism not important goal, rather information transferral.
        - **Node & Link diagrams**
            - Additional information held, than just what's obvious. E.g. in electrical diagram outputs on the right inputs on the left - and higher voltages generally on the top.
            - ![](https://lh3.googleusercontent.com/0puT7aFIsUsEPIZXVeAztkuFe_A4QoYFH-BM4BSACvwcsAlYJlCNhFbTCofCW9rEK3AKw0ow4B2gJ3oB_y3jNEeU_dD6tu208pgE_M8qZnI9R89ueZNUHGh0qDS-FgvuMAuiTZqVE5UP)   
        - **Icons and Symbols**
            - Pictorial way to imagine abstract and invisible things. 
            - Often used to spare on translation.
            - ![](https://lh5.googleusercontent.com/mDjefD5Re4TT8eRYR_eO1s0gJU3OQOSYOe42Z8OHDwfeNtR3k--bx5dSN1qmk9oKTZ107SEWRwHaKBtqTqOYd85KdFnf9JezjAFyrclDRXwbEsjEe6ZyM9eaTM8nI8-imuox3PTrz0O4)   
        - **Visual Metaphor**
            - Describing icons using well understood visual metaphors.
            - ![](https://lh4.googleusercontent.com/t6Pr9efDUTXgJGzGnOdV1mr2bnZonO15xpYeLt4UoG73T25c8_J-mj3w60w8yIrS6j6atvVLIYDnnAv1rnxfPosIsMbrCXTkSczAGN9y6K1XcWQP2RDh7GWmIyKZ5ZA8w2lRgeiNfUoV)   
            - This example has the pictorial and the reality truly linked. However this is a backwards step.
            - Another example of pictorial representations linked to reality.
![](https://lh6.googleusercontent.com/Mp-Bo470_SKnnOJS-509IzYvOkfuIH5vKqqoFf2BvtqjMkBur2V00zgE5Oiayg4pVBqPg1FG2nNiqaMHLbX2T3uburvZ7gDbrce275XvwSb6NSV_A6j32azXPZ-GSxyGEy6GxL6StN27)   
        - **Pictures** 
            - Perspective is a convention. More important people made bigger, less important better. Perspective is some set of conventions where the real image is mapped to a representation.
            - Pictorial representations **are not **necessarily just **seeing the same through the camera as through your eye.** 
            - ![](https://lh6.googleusercontent.com/QLU6UrrtyGvAmLYWcatL6Tp9iLqwomy17HpzJI3x2HjVLtz2dhz0MMWkC8IK2FavcGl-xU2X4hxL1FzMLPaK7_bKfuCw2OoVJ5vtJ0TXhIJJka_3sUYHYYrsUvcpYbq8B8a5eXoO9kKC) 
            - ![](https://lh4.googleusercontent.com/l3imO908S94W-NkbIdSZZ71NS7b3ToNOzw8f7y901XJZRL_7qIQFCE4SUybCONmyTGa1WNgOX5dnHi8r9noHDQiLj_Rt2oDZb52fAx-gdgmaQt5CIcm2JLxl4s9LhOXbOov3TL0bq2k2)   
    - **Theories of visual design **
        - Categorization (taxonomy): ![](local:///home/mali/remnote/remnote-614c8a3b6997e6001643dfce/files/GfCU1QRYGN2ucr98Aw_LIdWJtfnsgFrYOcW_3dNMwT6FIdIsUn3xz68TDhT6qvH6oLScSncZ8kW57UbgrWXhULM74rFRhB00eVN0KKdaYiwnrxxkODO6xq7Es4qs7YZe.png) 
        - Use 1: Usability analysis
            - Analyse a design by considering the expected encoding and the actual encoding: 
            - ![](local:///home/mali/remnote/remnote-614c8a3b6997e6001643dfce/files/qfhWw9Bfmhd-IfhdsvXNAnRXFzyadPU1fF_GLfBnYs0y51fK70-B9W2z6kqjIltkeH9PWNzhqEgWa8C3xRcWOA-VE8Pq-_l40IcH9nLoqlCW-CaNml2u_wyDzicVQ24X.png) 
            - Selecting an item uses Colour, the convention that the colour is blue, and categorical selection of the item.
![](local:///home/mali/remnote/remnote-614c8a3b6997e6001643dfce/files/s6AtkXXvZbtQpGYObn2tXhApUHcX3hQARDlFBAL85LrgFFDEvXLaoh0KjsDu__N-NuazJH7Tlhy1v_NohQdzGHaIdRJwKp2uWFDEkVU8Z1oXc8xJ05SEwxu6pCfuqQFl.png) 
            - 
- 
-  _**Lecture 4**_   Designing efficient systems
    - Fundamental trade off in efficiency - speed vs accuracy. Need to consider, does you application require speed or accuracy?
    - **Fitts' Law**
        - ![](local:///home/mali/remnote/remnote-614c8a3b6997e6001643dfce/files/7Mt2ZvmgHNDuTg277_WW-eAMkuG5nOjy2He6mY59X-UAlWB-4C9AFp5XxOKkCf66ZLAVBflAd9WnXXTLy52kI2GZz2ueUjkhYFF6WLMMPEXIgPsNjdD5rRxEkEER66NT.png) 
        - Selecting large thing from small group easier than small things from large group  
        - **How long does it take to point at something**
        - Proportional to the Distance to the target, Inversely proportional to the Width of the target.  
        - Time = k log(2D / W)
        - **Hacking Fitt's Law**
            - Semantic pointing - cursor slows down over the save button:
            - ![](local:///home/mali/remnote/remnote-614c8a3b6997e6001643dfce/files/n1fW4C9vTrQPdRc1-3VHn5caAmpfzu8WCJ6Y9diloWE8Rj-1siuBsK0BWNTmQrTN5spy3B5xKWBV6ABCmVqSzb0CXFCZmY4jyhR8O3EHlAMQPqjwAW59Fck0exRfoSCE.png) 
    - **Small changes can have a big effect**
        - Nested hierarchical structure of IF ELSES, use JUMPS - which is better?
        - ![](local:///home/mali/remnote/remnote-614c8a3b6997e6001643dfce/files/MCkLIrGwCRQ1wKtgW-cGUeqK9CPuWlsntCoMYkA63eq6A6UnuBHo66jkVaK9hWng-ozDf8Gh_XrwrxxzM4fRDvUtozg1yLqj3qPO64wMfyTsaekTHBEWxu4icb9KuvqV.png) 
        - Statistically significant increase in performance.
    - **KLM.GOMS: Predicting time**
        - Break time down into discrete stages, and apply some heuristics (TM) and figure out the time taken to perform an action.
        - Predictive model based on theory.
        - ![](local:///home/mali/remnote/remnote-614c8a3b6997e6001643dfce/files/DHDcWvz_y6O3HNUAMI0bSRRbPJt-dQXSin0povO__CoNk1lkrijvqIjIsYP8V0GT0s70Wwir2gBA3t0a0O1kb57ob70419d571K0PhL4F4hx3nWYtsVji85jBSxWXhAw.png) 
    - **A/ B Experiments**
        - **How many links should be on a search results page?**
            - User studies found that 30 is better - however, serving an extra 20 results on a page added another 0.4 seconds of latency.
            - Latency experiment
                - Have an experiment group with an added 400ms of latency (still with 10 items). Also have a control group with no changes. 
                - Result was that usage dropped 0.74% after 6 weeks 
        - Fit a gaussian to a histogram. Then introduce an  __experimental treatment __ (some modification expected to have an effect on usability). Then examine the distribution of results after the change. Use  __Hypothesis Testing.__  
        - ![](local:///home/mali/remnote/remnote-614c8a3b6997e6001643dfce/files/qM3yJvfPX8tAx0JNAofERXKb6dUfyVo1DUEwRm19FNeGrQoEeLMyWRmyPfu6-vw4NudlDQTEKRs2zC8QPymfBc_tgUQgqOEEEedOBbZvlPmxEOk2fKq7PPMnb4ztT9ET.png) 
        - **Sign tests**
            - Have each person complete the task twice, using the two different systems. Explores the null hypothesis that the median of the pairs is zero??? What this mean?? 
            - Change could be milliseconds, not necessarily important.
            - Apparently not very powerful?
            - ![](local:///home/mali/remnote/remnote-614c8a3b6997e6001643dfce/files/mLj1gOa5FZAKcVF6PxNFXiRDLSvAX3563WOuAIXgIqxf5CLXaXLdXd-xwURl6Lwg8c2gkdbyB8p8OIFXrsVZIVrfQheTBJv4NLhTgeFB8dj5w49qiscELPnxe_pci8PN.png) 
        - **Sources of variation**
            - People differ, need quantitative and statistical approaches
            - Might have distractions
            - Might have varying motivations (mondays)
            - Might have accidental intervention by experimenter (hints)
        - **Problem with controlled experiments**
            - **Huge **variation between people! (~200%)
            - Small mistakes can result in huge variation in accuracy (~1000%)
            - Improvements often small (~20%)
                - or negative (because new & unfamiliar)
                - or improvement can result form something unrelated to the design
        - **The Hawthorne Effect** 
            - Does lighting levels affect productivity? Studies appeared to show improvements when lights got brighter **and **when they brought the lights back down again. 
            - The **motivational effect of being studied, improved productivity.** 
        - **Taylorism**  
            - Productivity and efficiency driven desiign - studied **scientific management. **Measure workers as parts in a machine, **optimize by measurement and correction.** 
            - Not popular with trade unions.
        - HCI studies often seek to optimize for goals of employers rather than users - efficiency vs creativity? 
        - **Efficient Creativity?**
            - What if there isn't a good measure of productivity. I.e. maximise number of notes player per second?
            - What if measure user enjoyment?
            - 
-  _**Lecture 5**_   Designing smart systems
    - Uniform text entry 
        - Should the keys be placed in a different order?
        - Why is caps lock bigger than the letter e?
        - Information gain per key press = $\log (\frac{1}{p(x_i)})$ 
        - Consider, u almost always follows q. 
        - Similar to hacking Fitt's law - shouldn't we have a non-uniform system as the probabilty of picking a certain key is non-uniform
    - Problem with:
        - ![](local:///home/mali/remnote/remnote-614c8a3b6997e6001643dfce/files/CC5K94uM6EtOQBnYaX8ka7pQzc7wlcxUszhvUx7AJdna7stzIthmjLa_4kGC35j3zeT99gJl1aqwyjxEnduUcYf5AB2h7iBJIl6-bAnTfZuDey-dmr2ubh5ZTRWz5QU_.png) 
        - Engrams vs Bigrams - sequence of two characters more common. 
        - No punctuation - even if you had it - source code uses # a lot people use it very rarely. 
    - **Some lessons from DasherUI**
        - Converting an information theoretic model into a UI requires creativity
        - Simply models can be more effective than complex ones (nGrams vs neural nets)
    - **Artificial Languages**
        - ![](local:///home/mali/remnote/remnote-614c8a3b6997e6001643dfce/files/qtp9TFvD5DYmo5-uRzyyaQkPBVjGlnuCCjA1yCSNnner4uLVZ9-Qag5_7ctiSSPTe8B13tJMrP5XawvRDmgHq_XxnRC5DOV-n1mqBkJN03OAOHVtdGS5tyfG4l9VFDPc.png) 
        - Ordering code completion suggestions
            - Consider a stopwatch API, we'll never want to stop the stopwatch before it's started. 
            - Rather than manually encoding this - we can try loading this from previous source code. We use Bayes rule, with:
![](local:///home/mali/remnote/remnote-614c8a3b6997e6001643dfce/files/W_WDPhOoWl8akDX08RNMxdUp-ofzLDmtrMYDl0kf6cV4GBm_YZdWCTlO1qMI8f1a3gWUmrB3PGwRlKwsTBEXpaAKdm6Uao-R7karFjMsatpf6uh-PfS1Kqfbun1iP_MK.png) 
            - ![](local:///home/mali/remnote/remnote-614c8a3b6997e6001643dfce/files/pSSlUplcHko3HgV1W6ht1qGCGzZoM7kBSGS0-Fd2lSumtij5qjf04vKHSlhsHOQ2E-wN9H6V6y5J5kAdeHGtXqjMSpzERIiS5hbdAyTGkgUw0IWdEqMpYcazuozLF1jT.png) 
            - Problems with code completion based on efficiency
                - Now can't search alphabetically
                - If your doing abnormal things in the language - it's less likely to suggest it
                - Norms reinforced by this system - if encoding defects bad
        - **Building User interfaces**
            - Many ways of text input to phones, 
            - ![](https://lh3.googleusercontent.com/Tpe3BWZclFubSvrjx0zC7TKZAUgjhnZ1RB-uQ_rQkdZugF0KY7mrbXTIBE3lCOsrhmjdUmg8odGrcIZJCiGzNh07SleErTgUDsEryjTjbZrfD4_Mi7qu9z-GF6uD-7TxBgeWYJs_j3VN)   
            - When will people switch over?
            - ![](local:///home/mali/remnote/remnote-614c8a3b6997e6001643dfce/files/ugMSzEHQSltF4nf9sUTSMRTJLH7sUx5-kPzAXAQVUNcUrXd2Pm2ulSAAcjWL8gNLcu3sjG7w783chHHn8V5ySwRQj9Iwxgdy90VoqiZjLGPu9vhxgTZj0Pyg7tMXJzq2.png) 
            - Entry and error rate
            - Learning curve, familiarity and immediate efficacy
            - Form factor, presentation, time and comfort
            - User engagement
            - Visual attention and cognitive resources  - **Dasher, faster but user fatigue** 
            - Privacy - **Smartphone based inputs, personal learning model could reveal things. Entering your password?** 
            - Single vs Multi-character entry - **Entry mode differs depending on context** 
            - Specification vs Navigation
            - One/Two handed
            - Task integration
            - Robustness
            - Device independence
            - Computational demands
            - Manufacturing and support cost
            - Localisation
            - Market acceptance
            - 
            - In text entry, we want to **avoid the need for a visual feedback loop! No cognitive load. **So move from closed to open-loop. **Different from machine learning** 
            - Continuous novice-to-expert transition - so **avoid explicit learning** 
            - Path dependency - make sure it works the same independent of path taken
            - Flexibility - we have no way to know what our users will do, don't be prohibitive
            - Efficiency - Let users' creativity be the bottle-neck. Writing at the speed of thought
- 
-  _**Supervision 1**_  
    - **Q1 Visual Representation**  
        - ![](local:///home/mali/remnote/remnote-614c8a3b6997e6001643dfce/files/eZa9x50qbkHSVaY7-fPALMbDvEAI48nFGWJv5mkfpm2EHYoBF5Qq7_zosFp-AkjhuQDPxUV12rab7Um41YwEpcMEeE0KyyfTC0IKsQsCqBCLaaX09nn-MREPqis44fBn.png) 
        - **Explain the nature of the information structure that the user creates and interacts with  when using the site/application.**
The user has two main forms of interaction when using VLC media player - they have the interactions directly related to the current playback of the video being displayed, e.g. pause, resume, fast forward, change the volume etc. The other form of interaction is changing how the video is displayed - this can include changing the aspect ratio, enabling or disabling subtitles, changing the timing of said subtitles and more. 
While the immediate aspects of video control are made clear by permanently being displayed at the bottom of the screen (only hidden in full-screen mode when the mouse isn't moving), represented by ubiquitous symbols, the more complex controls are reached two main ways:
1. By selecting the class of setting you believe you'd like to access from the top bar (or from the right click menu):
![](local:///home/mali/remnote/remnote-614c8a3b6997e6001643dfce/files/1c78eNxZ6Rv1fK4sU2v-Rvfou7xdBCEEaQWe9OZo6pETdF6sMOgovqRBvBIEZLP95xP_1C8wYDJ1H_HRI2Db9ijwL1YyYNF6bQd_kw2-iNws7Sgf65el5Bhgv05CWN-K.png) ![](local:///home/mali/remnote/remnote-614c8a3b6997e6001643dfce/files/WmDV2MsXr52rBMSYAswm_ReaFfbYPGjvKrqKXLI7p4WMX_wNszJFXzPCAMe-LthGw_w9wNtBIf4Fv8w7rEhya3Gt5lnwfshS8p3rvV52aW9dEUdlhB6A7lKlV7S91SGS.png) 
2. By navigating to the search menu, and searching for the specific setting you'd like to change. Where an in depth list of possible settings is shown:
![](local:///home/mali/remnote/remnote-614c8a3b6997e6001643dfce/files/H5QhIRMbJa4rEpgQOcnwlaAX8RbGWcuZ-a11Cxs-41fLDs4hAIFNhnuXck16sOAZNCA-hM3pRPcygmTbETZyn0RTGA5MST2crZYSGY4cve1AKQJQlrK_bxhXrpe5k2oB.png) 

However, for some requirements the second option is not possible. For example, if we wish to select a video to watch - we can only use the top/right click bar, at which point you are taken to your file manager to search for the video:
![](local:///home/mali/remnote/remnote-614c8a3b6997e6001643dfce/files/xgS8bzU5yrqZDvnlCIse5IZMC2OgfTOvsVmQEK8ghbFk7z_QXwf2ceAiDdtaqL-XaBIl4PNiayRGSJV1Amu1jaG4RFIrpDsbtPZXdYTAPZ7nWQkvQE-INetmoIuEgDM9.png)

        - **Describe the aspects that make it an enjoyable/efficient (or an unenjoyable /  inefficient) interaction experience by focusing on the aspects of the visual language  (marks, symbols, regions, surfaces). For each aspect, explain the nature of the  correspondence between the visual appearance and its meaning or purpose within  the interaction design.  **
        - The use of **well know symbols** to represent actions the user can perform has benefits and downsides. The benefits are that the most important features for a video player (pause, play, fast forward and stop) are obvious and easy to use - and anyone who has any experience with a TV remote (almost everyone) can jump in and use the software straight away. However, the other symbols are less obvious: 
![](local:///home/mali/remnote/remnote-614c8a3b6997e6001643dfce/files/vWxgypLYTy78rBWXyalEfjsrV3Kx285-_adTP_nq7ELZlrbUFbZzNuxjzTM3GIFWeepyCv-L34pp67EHuDtAwulZAyZzHnC9ozHCCGbaEzgzH7Ha7NlMH2YkedNFC7sS.png)
And even as a user of VLC for many years I would have to guess at what the last 3 buttons do. Whether the symbols could be improved notwithstanding, there is no explanation of the buttons to the user - the result of this is they become useless. While they are supposed to be a faster alternative to a long winded settings search, because their usage is opaque they don't see much use.
VLC also uses intelligent symbols within dropdown settings bar, a very clever addition that often draws your eye to the settings your looking for:
![](local:///home/mali/remnote/remnote-614c8a3b6997e6001643dfce/files/fzuw2mAfObbfRp2qaQ6UG94sVai5ZuhQxwZZEwc5Gr6tyt6dLe2qHBuYTA4JEMfA4dCQOoyxW7iO2wyu5e-CMnLByE0qa5Ol-rAmmur-rtlG8bQnDpuENbMg6LzuQg5L.png) 
        - **Information hiding** (within categories of settings, or within the larger settings bar) is used to hide unneeded detail from the average user, while making individual settings easier to find if you do need them. This allows VLC to have a large suite of useful video settings (and allows for plugins that can add even more features) while still making the program intuitive and easy to use for the average user.
The downsides of such a system, is that the categorization of settings can be confusing. For example, if I want to find out the framerate of the film I'm watching - instead of going to video, I need to go to Tools and click on Media Information.
![](local:///home/mali/remnote/remnote-614c8a3b6997e6001643dfce/files/Xn4Ay53siSiJbK6TTXhUoa3IhQ66uhd1L9p68Ez2f1Pjv4PYNNGfN366WjqMN7Nw1whGtMIs-KQBGNrrXnTp-Ai4Ew7m9CBf-dXMpYcJIQpBhUtE1HWIo3Nd-uVI2hsh.png)![](local:///home/mali/remnote/remnote-614c8a3b6997e6001643dfce/files/fzuw2mAfObbfRp2qaQ6UG94sVai5ZuhQxwZZEwc5Gr6tyt6dLe2qHBuYTA4JEMfA4dCQOoyxW7iO2wyu5e-CMnLByE0qa5Ol-rAmmur-rtlG8bQnDpuENbMg6LzuQg5L.png) 
Additionally, the visuals of having a cleanly separated concise bottom bar is much more pleasing than looking at a wall of text:
![](local:///home/mali/remnote/remnote-614c8a3b6997e6001643dfce/files/H5QhIRMbJa4rEpgQOcnwlaAX8RbGWcuZ-a11Cxs-41fLDs4hAIFNhnuXck16sOAZNCA-hM3pRPcygmTbETZyn0RTGA5MST2crZYSGY4cve1AKQJQlrK_bxhXrpe5k2oB.png) 
Where do I look? Just Video as a setting is far to coarse, perhaps the settings I'm really looking for should be highlighted. Or the settings should be arranged into smaller groups.
        - ![](local:///home/mali/remnote/remnote-614c8a3b6997e6001643dfce/files/j4pqw3Xf7xAugNL3yD4p5Gxo5tWQgv-q87KB3DdvJTN8vOQmtHs5yoSwAgLp6eM6x3iKB-lzNNJr3Vtu2GkrOKEXacLSPTn_6SyK_SxFVIkTUDXcVmED8yhk8JTr6w5i.png) 
        - **Explain the nature of the information structure that the user creates and interacts with  when using the site/application.**  
The site displays 3 main classes of information:
1. The symbol input mechanism - this groups different types of input into blocks to allow for easy visual categorization, for example digits 0-9 are grouped into a block of digits and mathematical formulae like $a^2 \  \text{ and } \  \| a \|$ are similarly grouped.
2. Previously evaluated expressions - computations are arranged in rectangular strips where the input expression and the output are clearly separated by a large gap in-between the two.
3. Higher level website features like Sign in / Sign up, these are made smaller (as in general they are less important) and positioned at the top of the screen where they are unlikely to be a distraction. 
The average user will go interacting with 2 to interacting with 1 after they've evaluated their expression, perhaps comparing to a previous computation or changing the expression upon viewing the output.
        - **Describe the aspects that make it an enjoyable/efficient (or an unenjoyable /  inefficient) interaction experience by focusing on the aspects of the visual language  (marks, symbols, regions, surfaces). For each aspect, explain the nature of the  correspondence between the visual appearance and its meaning or purpose within  the interaction design.**   

**Important information is hidden **as in VLC, this is done to hide rarely used features to lessen the mental load on the user - however for a program like this, using sin & cos is **very **common. 
![](local:///home/mali/remnote/remnote-614c8a3b6997e6001643dfce/files/itzgXFZVQ5wWqGSX5PIeX_1L6vrELQW4kNvSHzw1ZtNCScnZ4tEPGKE1ztcvc8wq1-xcLQh-nnFqFi_j4h3aWT9gUI109MHHCaNtAnY1w46dxaEhXz6HJLU8UdgBOCTZ.png)
**Useless input mechanisms, **many of the options provided by the calculator are useless in the general use-case as 99% of devices have them built in. For example, when using my laptop I have no use for the number input mechanism, the backwards/forwards mechanism (with delete and enter) nor the letter input mechanism:
![](local:///home/mali/remnote/remnote-614c8a3b6997e6001643dfce/files/nsKPbV_sQCflpZp2_31ICY23txKNxcAx9LgWjNh72Q1kycj563eW4vHvuK7jdtvDlFAKK8q-4HWSf_yauD7CF9wxRPz0b3eN2yBrq1dSrkT-ZC3J-gthIreV6w9j8t9n.png)![](local:///home/mali/remnote/remnote-614c8a3b6997e6001643dfce/files/-4kMrmv5gwdb3A7RbN7yqO8Nb3zsdO8QGf8hRyrvej_3hF4XitnUfAT9C5jt9FMHpPaXAjLz6gRokof5ttXfyF3ZWJoOiSQl5HAf4t2AZkhKOMRNBzLmOBg7BLsNfuEm.png)![](local:///home/mali/remnote/remnote-614c8a3b6997e6001643dfce/files/4w_IL0pGhVosrYgfySC56RW-RgelJQaORBjkU89q38_wYxktQPuYh5JY82tQ4d7N00zIpVEkxzxhyw5rKXI1ozSXEYnME4d6zuZWKXIRdEoOmGfSuAlCTFaDo09uMadX.png)
While the first is unimportant as this section is filed away in "abc", the latter **is **of import as it takes up a large amount of the main screen with what could instead be less obvious functions the user may find useful (for example the non-obvious nCr function organized nCr(n, r)). 

The user **reorganize previous lines **if a previous calculation is important to the current one you need to rewrite it. Below we can't reorganize this to have $a$'s definition just above $a^{10}-3$ 
![](local:///home/mali/remnote/remnote-614c8a3b6997e6001643dfce/files/koToGcJfAryzThfZGEvsx14cC80qjms4IyfTajRK4WS3UZWkDhmZTFV0Bx5qeudKsOZtyVgnWZ11E0-v7_bl8MTq3l4ZiqYL1PCObuYPSBx4TP_6DAUXTTBmlsfiX_VM.png)

This also illustrates another important issue, there is **no clear disambiguation between mathematical constants and variables. **In the above examples $e=3131$ has thrown an error because $e$ is a constant which you can't give a value to. 
 
        - **Redesign the second interface in order to address its poorly designed aspects. Provide a  sketch of your design and comment on how the deficiencies you noted above are specifically  addressed and any trade-offs that you had to make.**
In a redesign (targeting non‒mobile usage where the usages will be more simplistic), I would solve the problem of important information being hidden and useless input mechanisms being present by first **moving the number keys input and arrow navigation to a different tab **(as is done with letters normally). I would further add a method of reorganizing lines, the user would do this by clicking and dragging and a method of adding items you use a lot on the right hand side of  the input - these added items should always be present on the right side of the input bar.
Finally, I would **make the mathematical constants bold** - and the logic of accessing them would be if you type e without having a variable e defined, the bold e would appear (as in most cases the user would want to use the constant, not define a new variable). However, if you define your own version of e this would take precedence and the constant would have to be accessed by the menu (or by special keyboard input method like "e"). 
![](local:///home/mali/remnote/remnote-614c8a3b6997e6001643dfce/files/j99RsA08D2Bi2Lb0Jz51QLMlGAt5ntG_Hwc37ecmYtbvdXlHFJdz6sDmjZK6KApbP2WXrDPln1YnTqRVLdY5IAHLOMi-acbKetbt8VjnhPZC74S7UmK9PrOgXzpaQQvA.png) 
    - 
    - **Q2 Iterative design**   
        1. **Start by sketching at least 10 different possible ideas of how this interface may look like
**![](local:///home/mali/remnote/remnote-614c8a3b6997e6001643dfce/files/HpdAHPwjigF6woSOkF65DksRVYIWZzfDNruMPFdy1VinGkPsH_AEHLpwRVqaUsLgovu-hzgnjL81lXgPP9vkZ37ddXiU1gwD7iqq_PIBVPxd2_gN42W8u_TF7pXtMNC-.png)**   **  
        2. **Using one or more of the analytical methods discussed so far in the lectures, discuss  which parts of the interfaces you sketched are better than the others  

**According to Gestalt principles the grouping of input tokens into blocks allows for better readability, thus grouping the keypad in designs 3 and 9 is better than 5 who groups based on arbitrary circles.
The lectures discuss the trade-off of Speed VS Accuracy of human motor skills, thus design 8 poses a problem - as the speeds required to punch the speedball will allow for little accuracy in setting a temperature.
Well understood metaphors for human-computer interaction lead to faster understanding of a system, and results in less initial errors. Thus, systems that are common already will perform well - e.g. 1,2 and 3. 
Given how human thinking is characterized as being boundedly rational (and with a limited attention span), we can determine opaque designs like 8 and 7 will not get far without additional explanation. While 1, 2, 3 and 10 are easier to understand at first glance. 
Hidden state in a system can lead to confusion and inefficient usage (A common example being more than 1 CLEAR presses is required to clear a calculator memory, leading to users pressing the button multiple times before moving on), in that way the current temperature is hidden almost everywhere except in 3. Meaning a slow working central heating system could result in the user thinking the thermostat isn't working.
        3. ![](local:///home/mali/remnote/remnote-614c8a3b6997e6001643dfce/files/y5bNgrV3uvKdhCJNU4gDluJ2LDdJR98eB2w_k7FEqnZfYeh-TqzEe3Z-V0gi3Z7qD6FwztWdjNQO84wYhRIMCHRqRBsE7azE0j62McGrJkpaNIBVb8NCTK2qmuPes6FZ.png) 
    - 
    - **Q3 Three waves of HCI **
        - If HCI methods were applied to the design of a programming language and waves of HCI tools, what research questions might be explored, according to the concerns of  first wave, second wave, and third wave HCI respectively? What empirical methods might be appropriate for studying programming from the  perspective of each of these three waves?
            - First Wave: The efficiency of the programmer when interfacing with the programming language would be studied, this interface being a separate module to the system itself. This could be the design of the keyboard used to input the commands, or the design of the screen used to display text on the screen. Methods from cognitive science would be used to model users’ perception, decision and action processes and predict usability.
            - Second Wave: The programming language would have to be considered as part of a larger social system, so the mug with different git commands written on it might have to be considered. More generally, communication between developers and the parts of the "program" stored cognitively would have to be designed around. An empirical study into the context people work via ethnography and Contextual Inquiry could be undertaken to understand other people's way of seeing the world.
            - Third Wave: Programming languages would have to be designed in a culture where computers are ubiquitous, and a programmer may use one language at work and another at home. The second being a discretionary choice. Languages might consider the aesthetics of the programming language (Is scoping with {} uglier than scoping with tabs?) and the fact that if not mandated to keep using a programming language by their boss, developers might move on. Design experiments become more like works of art, speculative and interpretive, with critical assessment of how this is meaningful within a particular  tradition.  
        - 
        - 
-  _**Supervision 2**_ 
    - **Q1** : 
        - Fitt's law says that the time taken for a human being to point at an item (this could be pointing at button with a mouse cursor) is a function of the distance from the item divided by the width of the item: $$\text{Fitts Law: \ \ \ Time} \propto \log{\frac{2D}{W}}$$
This means that larger buttons are easier (and thus faster) to click on - additionally if buttons are introduced close to the users cursor, they can be reached faster. 

This ratio of distance to width is the  __index of difficulty __ and can be understood as the potential amount of information gained by the system when the user points (selecting a small target from a wide range reflects greater information gain).
![](local:///home/mali/remnote/remnote-614c8a3b6997e6001643dfce/files/l3EEwcZaXHBkhmwX-BGmeOUfKKiJ60RKYloQXLM8G-7LBIUov7lUT3OBvck_EDKXdb0aQNImIYry425QE3WVTFXay1ljqF-2KP_7qzZunozGrEdkxw80ChQw6NfbzXAr.png) 
        - Consider Fitt's law we quickly note that layout B has wider buttons (decreasing the index of difficulty and making the buttons faster to click) arranged in a grid, while the average distance to each button is further in layout A if the mouse starts at the centre; if the mouse starts at the top of the screen the average distance is lower in Layout A (lowering the index of difficulty).

However, such an approach to selecting the better interface is too simplistic - we must also consider which button is used the most: If the settings button is the most used button, then the decrease in average distance from the button by making it larger could be worth the trade-off in making the other buttons smaller. However, if all the buttons are used the same amount Fitts law would tell us Layout B would be more effective.
    - 
    - 
    - 
    - 
    - **Q2: **
        - **Is efficiency always a design goal? **
While efficiency can be a admirable design goal, every resultant system resides on a Pareto frontier of optimization decisions; trade-offs are always present, and designing solely for efficiency has its own trade-offs. 

One school of thought for design is Taylorism, this method describes the optimization of workers in an industrial context wherein workers are modelled akin to machines. Within Taylorism overseers are introduced who use various scientific management techniques to measure workers effectiveness and productivity, these measurements are then leveraged to improve efficiency. This has immediate problems, one being that humans change their behaviours under study (called the Hawthorne effect) - however even if we correct for this issue other philosophies disagree with this method.

However different paradigms exist for example akin to the Second wave of HCI: rather than the workers being a machine to be studied and improved, they should be involved in the design of the system and treated as collaborators in improving efficiency. Ethnography and contextual inquiry are employed in an effort to reach that goal, these methods rely on the fact that the workers have the greatest knowledge of how they work and are invested in removing obstacles reducing their effectiveness.

A third philosophy (Driving the Third wave of HCI) describes workers as discretionary users who are not under any job related obligation to use a system. This user has their own wants and goals, and efficiency may be last among those goals - instead a system can be designed to optimize for creative expression or personal enjoyment. Contrary to Taylorism, these goals may be difficult or impossible to quantify in an objective and scientific manner, instead qualitative investigation techniques must be employed.  
        - New designs 
            1. ![](local:///home/mali/remnote/remnote-614c8a3b6997e6001643dfce/files/CNfkXNGhM2Nts9ciTVJ35uL6bKnHpZtT8ltaveqF5oXfZznI7mbEg5mt98VzDZDWwpZgwBvW7mPY4ppfNWUpTDU9Haqx0znpoiqiANnvOpP5oJJ08k4d36wDP6Aw5Vcx.png)
The goal of this system is improving the mindfulness of the user, within every option a zen quote related to the option is shown (these could be cycled daily) with the goal of helping the user reach a state of calm reflection. Taking time to read and digest these quotes and encourage, and the only efficiency consideration will be that the buttons will always be in the same place so the user can skip past the quotes if needs be.
Mindfulness is a nebulous concept so it cannot be totally quantified in a meaningful way, however reading such zen quotes is a well known technique for reaching (in vain) towards mindfulness. 
            2. ![](local:///home/mali/remnote/remnote-614c8a3b6997e6001643dfce/files/U4Y7woOBx5dDo-0MIsjbb9f25XUDTNKcYACnAsI78RZPZJWz2iEs9EwCGneQa1zfjeOVUbeKkeSH-Gc1dBT0SY8GHdOWAMSlLMlkOc8TngjCpaqYtUTPdpFWD2ytCHOS.png) 
This system has buttons to play short sections of music, these music sections will be related to the function of the buttons and the user will be prompted to guess the function of each button! Once the user has guessed all the buttons correctly they can use the application. 
This system is designed to give the user a sense of satisfaction once they've correctly guessed the buttons, and provide some entertainment alongside an otherwise dry and regular app. The enjoyment is difficult to quantify meaningfully, however a poll of users could be taken and the enjoyment vs irritation at such a system could be measured.
    - **Q3:**
        - Scratch and TypeScript are very different languages, while Scratch is a visual **block-based Programming language **while TypeScript is a more traditional text based language built on top of JavaScript   
        - TRADEOFFS - why did they make this tradeoff
        - **Dimensions - Like viscosity:**
        - **Environment - surrounding options around the language, block selection tool - autocorrect - etc: **  
        - **Activities - What you do with the language:** 
        - The environment of scratch provides many utilities to the user, including all available variable combination functions, all available variables, Events, Sounds etc. These are grouped well which could reduce the  __Error-proneness __ of the system, however some of the menus require extensive scrolling to find what you're looking so  __Visibility __ is compromised. This trade-off of the number of categories vs the number of contained items is understandable, and in practise the less used items are placed lower where you'd have to scroll to find them. The environment also shows you the arrangement of items on the screen in real time, and allows you to drag items onto the screen - this immediate visibility makes the system feel more  __responsive __ and reduces  __error-proneness.__ 
The Typescript environment provides a different set of utilities, such as autocomplete and error checking. Autocomplete provides  __Visibility __ of the options for a specific object (e.g. the methods one can apply) however the options are often irrelevant and offers up  __Premature Commitment__  where you aren't yet sure what you want to autocomplete to!
Scratch and TypeScript share editor error-checking, this can be very helpful for spotting bugs early on and is a type of  __Progressive-Evaluation. __ However, there are cases where you are in the middle of changing a piece of code and (temporarily) your code is incorrect and thus covered in red errors - this does introduce some  __Viscosity __ and is a visual distraction where the  __Secondary Notation __ is otherwise stellar. This is a trade-off, as if a certain time period was waited before applying the highlighting the user could have switched tab and not noticed the error AND some users may find this added latency unpleasant. 
        - When considering the  __Viscosity __ of TypeScript vs Scratch, one must consider the facilities these languages provide to reduce resistance to change - TypeScript has features that could be considered resistance to change, for example if we have the following code: ```javascript
const arr = ["1", "2"];
function compact(arr: string[]) {...}
compact(arr)
``` if at some point I would like to change "arr" to contain integers rather than strings, I would either need to change the type signature in all function using arr - or create new functions to handle integers. The trade-off here being type safety versus viscosity.
Scratch could be considered even more resistant to change, for example consider the following code:
![](local:///home/mali/remnote/remnote-614c8a3b6997e6001643dfce/files/_IwxIxkD8kvCea2HOuURmTPUzuJ8U_JaM-ws-nd8rUmgUNvevc0PTLrhKMpxS5RggOL6doKDlar-YgR7IXW-qF76TvH1qwxf40GkHBvG1eaGshkquIUXVUpsFijlKwRK.png) 
If I want to change the x velocity variable, I would need to go through every example here (and in the surrounding code) and access a drop down (which in large programs could be lengthy) and find my variable to change it. This does eliminate the complexity of an automatic variable switching system, and as this is designed for younger users this reduction of complexity could be worthwhile.
        - Scratch has many  __Abstractions, __ user's don't have to think about how the canvas works or how to change the colour of a single pixel - this is replaced with controlling sprites **on **the canvas, easily modifying their position, rotation and size. This is a trade-off between low level control and ease of use, and as Scratch is aimed at a younger audience for whom the barrier of entry should be low, this trade-off is well worth the price. TypeScript also provides forms of abstractions, you don't have to specify the number of bits for types or describe where in memory they're to be stored (more a Javascript feature), TypeScript also adds interfaces which allow Object Oriented abstraction on types. 
    - **Q4:**
        - **Firework displays: Suggest an analytical method that would be appropriate for evaluating and refining the usability of this language and associated tools.**
        - Cognitive dimensional of notations analysis would be appropriate the usability of the language and associated tools, it forms a language of terms that can be used to clearly communicate language features and holdups - and through this language design decisions and the trade-offs they result in can be clearly discussed and understood.
    - **Q5:**
        - In terms of Cognitive dimensions analytical method proposed in Q4, define the target user, the nature of their task, and several specific usability requirements that would result from that task.  
        -  __Viscosity
__ The target user is someone who is required to run a fireworks display, thus target user will require a low level of viscosity - consider that once a single firework display has been designed, rearranging large chunks of the elements around creates a seemingly new display while requiring no new types of fireworks. Additionally, if a certain brand/type of firework cannot be found for the display, it should be possible to change a type of firework (the colour, brand, sound etc) in the display easily without disrupting other elements.
        -  __Hidden Dependencies__ 
The target user would like the minimum number of hidden dependencies as possible, this is because these dependencies can cause confusion and mistakes and as large firework displays can cost thousands of pounds the user of such a system would require clarity and ease of understanding in the code.    
        -  __Visibility__ 
The visibility of elements will be a priority for our users, they would like to be able to clearly see the arrangement, order of their fireworks and possible effect of their fireworks. To this end, a simulation of the display would be desirable by the user so they can be sure their design is exactly as they wanted it.
        -  __Premature Commitment
__ Premature commitment could be a problem, as often certain features of the fireworks or the display would not be known by the user to begin with - for example the user may be perplexed if immediately required to input the brand of firework when first attempting to design their display. On the other hand, for large displays the resources at the designers disposal will likely be outlined long beforehand - thus a middle-ground must be found between premature commitment while still allowing for early specification of resources. Additionally, the user would likely like there to be no early commitment to the layout or length of the display - as that may change over the design period.
    - **Q6:**
        - Choose one requirement identified in Q6, and describe in detail an empirical approach that  you would take to evaluating whether this requirement has been met.  
        - To test viscosity of the program, we could design a set of tasks like " __change the type of firework to pinwheel and the colour to green in this display__ " and measure the time it takes for a group of users to perform these tasks - we could then repeat these tasks on other state of the art fireworks programming languages and again measure the times taken. Thus, the programs viscosity can be empirically tested against other programs - or we can simply examine the results from our programming language and decide if they are within desireable bounds.
